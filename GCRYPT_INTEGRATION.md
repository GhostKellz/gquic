# GQUIC C/C++ Integration Guide

Complete guide for using GQUIC (GhostChain QUIC Protocol) from C and C++ projects via C FFI bindings.

## Table of Contents

- [Overview](#overview)
- [Building C Bindings](#building-c-bindings)
- [C Usage](#c-usage)
- [C++ Wrapper](#c-wrapper)
- [CMake Integration](#cmake-integration)
- [Connection Management](#connection-management)
- [Stream Operations](#stream-operations)
- [Error Handling](#error-handling)

## Overview

GQUIC provides C bindings that allow seamless integration with C and C++ networking applications. The bindings maintain the security, performance, and reliability characteristics of the Rust implementation while providing familiar C networking APIs.

## Building C Bindings

### Rust Library Setup

Configure the Rust project to build C-compatible binaries:

```toml
# Cargo.toml
[package]
name = "gquic-c"
version = "0.1.0"
edition = "2021"

[lib]
name = "gquic_c"
crate-type = ["cdylib", "staticlib"]

[dependencies]
gquic = { version = "0.1", features = ["std", "tls"] }
gcrypt = { version = "0.2", features = ["ed25519", "x25519"] }
tokio = { version = "1.0", features = ["rt-multi-thread"] }
libc = "0.2"

[build-dependencies]
cbindgen = "0.24"
```

### Build Script for Header Generation

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_dir = PathBuf::from(&crate_dir).join("include");

    std::fs::create_dir_all(&output_dir).unwrap();

    let output_file = output_dir.join("gquic.h");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("GQUIC_H")
        .with_documentation(true)
        .with_autogen_warning("/* Auto-generated by cbindgen */")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output_file);

    println!("cargo:rerun-if-changed=src/lib.rs");
}
```

### C FFI Implementation

```rust
// src/lib.rs
use gquic::{Connection, Endpoint, Config};
use gcrypt::protocols::{Ed25519, X25519};
use std::ptr;
use std::slice;
use std::ffi::{c_char, c_int, c_uint, c_void, CStr};
use libc::size_t;
use tokio::runtime::Runtime;

// Error codes
pub const GQUIC_SUCCESS: c_int = 0;
pub const GQUIC_ERROR_INVALID_INPUT: c_int = -1;
pub const GQUIC_ERROR_CONNECTION_FAILED: c_int = -2;
pub const GQUIC_ERROR_STREAM_FAILED: c_int = -3;
pub const GQUIC_ERROR_TIMEOUT: c_int = -4;
pub const GQUIC_ERROR_OUT_OF_MEMORY: c_int = -5;
pub const GQUIC_ERROR_CRYPTO_FAILED: c_int = -6;

// Opaque handle types
#[repr(C)]
pub struct gquic_endpoint_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct gquic_connection_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct gquic_stream_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct gquic_runtime_t {
    _private: [u8; 0],
}

// Configuration structure
#[repr(C)]
#[derive(Debug, Clone)]
pub struct gquic_config_t {
    pub max_idle_timeout_ms: u64,
    pub max_bi_streams: u64,
    pub max_uni_streams: u64,
    pub max_stream_data: u64,
    pub max_connection_data: u64,
    pub keep_alive_interval_ms: u64,
    pub enable_0rtt: c_int, // bool
}

impl Default for gquic_config_t {
    fn default() -> Self {
        Self {
            max_idle_timeout_ms: 30000,
            max_bi_streams: 100,
            max_uni_streams: 100,
            max_stream_data: 1024 * 1024,
            max_connection_data: 10 * 1024 * 1024,
            keep_alive_interval_ms: 5000,
            enable_0rtt: 0,
        }
    }
}

// Stream data structure
#[repr(C)]
#[derive(Debug)]
pub struct gquic_stream_data_t {
    pub data: *const u8,
    pub len: size_t,
    pub fin: c_int, // bool - end of stream
}

// Connection info
#[repr(C)]
#[derive(Debug)]
pub struct gquic_connection_info_t {
    pub peer_address: [c_char; 256],
    pub rtt_ms: u64,
    pub cwnd: u64,
    pub bytes_sent: u64,
    pub bytes_received: u64,
    pub packets_sent: u64,
    pub packets_received: u64,
    pub packets_lost: u64,
}

// Internal structures (not exposed to C)
struct InternalEndpoint {
    endpoint: Endpoint,
    runtime: Runtime,
}

struct InternalConnection {
    connection: Connection,
}

struct InternalStream {
    // Stream implementation
}

// Version information
#[no_mangle]
pub extern "C" fn gquic_version_string() -> *const c_char {
    b"gquic 0.1.0\0".as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn gquic_version_major() -> c_uint {
    0
}

#[no_mangle]
pub extern "C" fn gquic_version_minor() -> c_uint {
    1
}

#[no_mangle]
pub extern "C" fn gquic_version_patch() -> c_uint {
    0
}

// Runtime management
#[no_mangle]
pub extern "C" fn gquic_runtime_new() -> *mut gquic_runtime_t {
    let runtime = match Runtime::new() {
        Ok(rt) => rt,
        Err(_) => return ptr::null_mut(),
    };

    let boxed = Box::new(runtime);
    Box::into_raw(boxed) as *mut gquic_runtime_t
}

#[no_mangle]
pub extern "C" fn gquic_runtime_free(runtime: *mut gquic_runtime_t) {
    if !runtime.is_null() {
        unsafe {
            let _ = Box::from_raw(runtime as *mut Runtime);
        }
    }
}

// Endpoint management
#[no_mangle]
pub extern "C" fn gquic_endpoint_new(
    runtime: *mut gquic_runtime_t,
    bind_addr: *const c_char,
    config: *const gquic_config_t,
) -> *mut gquic_endpoint_t {
    if runtime.is_null() || bind_addr.is_null() {
        return ptr::null_mut();
    }

    let rt = unsafe { &*(runtime as *mut Runtime) };

    let addr_str = unsafe {
        match CStr::from_ptr(bind_addr).to_str() {
            Ok(s) => s,
            Err(_) => return ptr::null_mut(),
        }
    };

    let gquic_config = if config.is_null() {
        gquic_config_t::default()
    } else {
        unsafe { *config }
    };

    // Convert C config to Rust config
    let quic_config = Config::default()
        .max_idle_timeout(std::time::Duration::from_millis(gquic_config.max_idle_timeout_ms))
        .max_bi_streams(gquic_config.max_bi_streams)
        .max_uni_streams(gquic_config.max_uni_streams);

    let endpoint = match rt.block_on(async {
        Endpoint::server(addr_str.parse().ok()?, quic_config).await
    }) {
        Some(Ok(ep)) => ep,
        _ => return ptr::null_mut(),
    };

    let internal_endpoint = InternalEndpoint {
        endpoint,
        runtime: Runtime::new().unwrap(), // New runtime for this endpoint
    };

    let boxed = Box::new(internal_endpoint);
    Box::into_raw(boxed) as *mut gquic_endpoint_t
}

#[no_mangle]
pub extern "C" fn gquic_endpoint_free(endpoint: *mut gquic_endpoint_t) {
    if !endpoint.is_null() {
        unsafe {
            let _ = Box::from_raw(endpoint as *mut InternalEndpoint);
        }
    }
}

// Connection management
#[no_mangle]
pub extern "C" fn gquic_endpoint_connect(
    endpoint: *mut gquic_endpoint_t,
    server_addr: *const c_char,
    server_name: *const c_char,
) -> *mut gquic_connection_t {
    if endpoint.is_null() || server_addr.is_null() {
        return ptr::null_mut();
    }

    let internal_ep = unsafe { &mut *(endpoint as *mut InternalEndpoint) };

    let addr_str = unsafe {
        match CStr::from_ptr(server_addr).to_str() {
            Ok(s) => s,
            Err(_) => return ptr::null_mut(),
        }
    };

    let name_str = if server_name.is_null() {
        "localhost"
    } else {
        unsafe {
            match CStr::from_ptr(server_name).to_str() {
                Ok(s) => s,
                Err(_) => return ptr::null_mut(),
            }
        }
    };

    let connection = match internal_ep.runtime.block_on(async {
        internal_ep.endpoint.connect(addr_str.parse().ok()?, name_str).await
    }) {
        Some(Ok(conn)) => conn,
        _ => return ptr::null_mut(),
    };

    let internal_conn = InternalConnection { connection };
    let boxed = Box::new(internal_conn);
    Box::into_raw(boxed) as *mut gquic_connection_t
}

#[no_mangle]
pub extern "C" fn gquic_endpoint_accept(
    endpoint: *mut gquic_endpoint_t,
) -> *mut gquic_connection_t {
    if endpoint.is_null() {
        return ptr::null_mut();
    }

    let internal_ep = unsafe { &mut *(endpoint as *mut InternalEndpoint) };

    let connection = match internal_ep.runtime.block_on(async {
        internal_ep.endpoint.accept().await
    }) {
        Some(Ok(conn)) => conn,
        _ => return ptr::null_mut(),
    };

    let internal_conn = InternalConnection { connection };
    let boxed = Box::new(internal_conn);
    Box::into_raw(boxed) as *mut gquic_connection_t
}

#[no_mangle]
pub extern "C" fn gquic_connection_free(connection: *mut gquic_connection_t) {
    if !connection.is_null() {
        unsafe {
            let _ = Box::from_raw(connection as *mut InternalConnection);
        }
    }
}

// Stream operations
#[no_mangle]
pub extern "C" fn gquic_connection_open_bi_stream(
    connection: *mut gquic_connection_t,
) -> *mut gquic_stream_t {
    if connection.is_null() {
        return ptr::null_mut();
    }

    // Implementation for opening bidirectional stream
    // This is a simplified example
    ptr::null_mut()
}

#[no_mangle]
pub extern "C" fn gquic_stream_write(
    stream: *mut gquic_stream_t,
    data: *const u8,
    len: size_t,
) -> c_int {
    if stream.is_null() || data.is_null() || len == 0 {
        return GQUIC_ERROR_INVALID_INPUT;
    }

    // Implementation for writing to stream
    GQUIC_SUCCESS
}

#[no_mangle]
pub extern "C" fn gquic_stream_read(
    stream: *mut gquic_stream_t,
    buffer: *mut u8,
    buffer_len: size_t,
    bytes_read: *mut size_t,
) -> c_int {
    if stream.is_null() || buffer.is_null() || bytes_read.is_null() {
        return GQUIC_ERROR_INVALID_INPUT;
    }

    // Implementation for reading from stream
    unsafe {
        *bytes_read = 0;
    }

    GQUIC_SUCCESS
}

#[no_mangle]
pub extern "C" fn gquic_stream_close(stream: *mut gquic_stream_t) -> c_int {
    if stream.is_null() {
        return GQUIC_ERROR_INVALID_INPUT;
    }

    // Implementation for closing stream
    GQUIC_SUCCESS
}

#[no_mangle]
pub extern "C" fn gquic_stream_free(stream: *mut gquic_stream_t) {
    if !stream.is_null() {
        unsafe {
            let _ = Box::from_raw(stream as *mut InternalStream);
        }
    }
}

// Connection info
#[no_mangle]
pub extern "C" fn gquic_connection_info(
    connection: *mut gquic_connection_t,
    info: *mut gquic_connection_info_t,
) -> c_int {
    if connection.is_null() || info.is_null() {
        return GQUIC_ERROR_INVALID_INPUT;
    }

    unsafe {
        (*info).rtt_ms = 100; // Example values
        (*info).cwnd = 1024 * 1024;
        (*info).bytes_sent = 0;
        (*info).bytes_received = 0;
        (*info).packets_sent = 0;
        (*info).packets_received = 0;
        (*info).packets_lost = 0;
    }

    GQUIC_SUCCESS
}

// Utility functions
#[no_mangle]
pub extern "C" fn gquic_error_string(error_code: c_int) -> *const c_char {
    match error_code {
        GQUIC_SUCCESS => b"Success\0",
        GQUIC_ERROR_INVALID_INPUT => b"Invalid input\0",
        GQUIC_ERROR_CONNECTION_FAILED => b"Connection failed\0",
        GQUIC_ERROR_STREAM_FAILED => b"Stream operation failed\0",
        GQUIC_ERROR_TIMEOUT => b"Operation timed out\0",
        GQUIC_ERROR_OUT_OF_MEMORY => b"Out of memory\0",
        GQUIC_ERROR_CRYPTO_FAILED => b"Cryptographic operation failed\0",
        _ => b"Unknown error\0",
    }.as_ptr() as *const c_char
}
```

### Generated C Header

```c
/* Auto-generated by cbindgen */

#ifndef GQUIC_H
#define GQUIC_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Error codes
 */
#define GQUIC_SUCCESS 0
#define GQUIC_ERROR_INVALID_INPUT -1
#define GQUIC_ERROR_CONNECTION_FAILED -2
#define GQUIC_ERROR_STREAM_FAILED -3
#define GQUIC_ERROR_TIMEOUT -4
#define GQUIC_ERROR_OUT_OF_MEMORY -5
#define GQUIC_ERROR_CRYPTO_FAILED -6

/**
 * Opaque endpoint handle
 */
typedef struct gquic_endpoint_t gquic_endpoint_t;

/**
 * Opaque connection handle
 */
typedef struct gquic_connection_t gquic_connection_t;

/**
 * Opaque stream handle
 */
typedef struct gquic_stream_t gquic_stream_t;

/**
 * Opaque runtime handle
 */
typedef struct gquic_runtime_t gquic_runtime_t;

/**
 * QUIC configuration
 */
typedef struct gquic_config_t {
  uint64_t max_idle_timeout_ms;
  uint64_t max_bi_streams;
  uint64_t max_uni_streams;
  uint64_t max_stream_data;
  uint64_t max_connection_data;
  uint64_t keep_alive_interval_ms;
  int enable_0rtt;
} gquic_config_t;

/**
 * Stream data structure
 */
typedef struct gquic_stream_data_t {
  const uint8_t *data;
  size_t len;
  int fin;
} gquic_stream_data_t;

/**
 * Connection statistics
 */
typedef struct gquic_connection_info_t {
  char peer_address[256];
  uint64_t rtt_ms;
  uint64_t cwnd;
  uint64_t bytes_sent;
  uint64_t bytes_received;
  uint64_t packets_sent;
  uint64_t packets_received;
  uint64_t packets_lost;
} gquic_connection_info_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get GQUIC version string
 */
const char *gquic_version_string(void);

/**
 * Get major version number
 */
unsigned int gquic_version_major(void);

/**
 * Get minor version number
 */
unsigned int gquic_version_minor(void);

/**
 * Get patch version number
 */
unsigned int gquic_version_patch(void);

/**
 * Create a new async runtime
 */
gquic_runtime_t *gquic_runtime_new(void);

/**
 * Free async runtime
 */
void gquic_runtime_free(gquic_runtime_t *runtime);

/**
 * Create a new QUIC endpoint
 */
gquic_endpoint_t *gquic_endpoint_new(gquic_runtime_t *runtime,
                                    const char *bind_addr,
                                    const gquic_config_t *config);

/**
 * Free QUIC endpoint
 */
void gquic_endpoint_free(gquic_endpoint_t *endpoint);

/**
 * Connect to a QUIC server
 */
gquic_connection_t *gquic_endpoint_connect(gquic_endpoint_t *endpoint,
                                          const char *server_addr,
                                          const char *server_name);

/**
 * Accept incoming connection
 */
gquic_connection_t *gquic_endpoint_accept(gquic_endpoint_t *endpoint);

/**
 * Free QUIC connection
 */
void gquic_connection_free(gquic_connection_t *connection);

/**
 * Open a bidirectional stream
 */
gquic_stream_t *gquic_connection_open_bi_stream(gquic_connection_t *connection);

/**
 * Write data to stream
 */
int gquic_stream_write(gquic_stream_t *stream, const uint8_t *data, size_t len);

/**
 * Read data from stream
 */
int gquic_stream_read(gquic_stream_t *stream,
                     uint8_t *buffer,
                     size_t buffer_len,
                     size_t *bytes_read);

/**
 * Close stream
 */
int gquic_stream_close(gquic_stream_t *stream);

/**
 * Free stream
 */
void gquic_stream_free(gquic_stream_t *stream);

/**
 * Get connection statistics
 */
int gquic_connection_info(gquic_connection_t *connection,
                         gquic_connection_info_t *info);

/**
 * Get error message for error code
 */
const char *gquic_error_string(int error_code);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* GQUIC_H */
```

## C Usage

### Basic C Example

```c
// client_example.c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "gquic.h"

int main() {
    printf("GQUIC version: %s\n", gquic_version_string());

    // Create runtime
    gquic_runtime_t *runtime = gquic_runtime_new();
    assert(runtime != NULL);

    // Test client connection
    test_client_connection(runtime);

    // Cleanup
    gquic_runtime_free(runtime);

    printf("GQUIC client test completed!\n");
    return 0;
}

void test_client_connection(gquic_runtime_t *runtime) {
    // Configure QUIC settings
    gquic_config_t config = {
        .max_idle_timeout_ms = 30000,
        .max_bi_streams = 100,
        .max_uni_streams = 100,
        .max_stream_data = 1024 * 1024,
        .max_connection_data = 10 * 1024 * 1024,
        .keep_alive_interval_ms = 5000,
        .enable_0rtt = 0,
    };

    // Create client endpoint
    gquic_endpoint_t *client = gquic_endpoint_new(runtime, "0.0.0.0:0", &config);
    assert(client != NULL);

    // Connect to server
    gquic_connection_t *conn = gquic_endpoint_connect(
        client,
        "127.0.0.1:4433",
        "localhost"
    );

    if (conn != NULL) {
        printf("✓ Connected to QUIC server\n");

        // Open a stream
        gquic_stream_t *stream = gquic_connection_open_bi_stream(conn);
        if (stream != NULL) {
            // Send data
            const char *message = "Hello QUIC!";
            int result = gquic_stream_write(
                stream,
                (const uint8_t*)message,
                strlen(message)
            );

            if (result == GQUIC_SUCCESS) {
                printf("✓ Sent message: %s\n", message);
            }

            // Read response
            uint8_t buffer[1024];
            size_t bytes_read;
            result = gquic_stream_read(stream, buffer, sizeof(buffer), &bytes_read);

            if (result == GQUIC_SUCCESS && bytes_read > 0) {
                buffer[bytes_read] = '\0';
                printf("✓ Received response: %s\n", buffer);
            }

            // Get connection info
            gquic_connection_info_t info;
            if (gquic_connection_info(conn, &info) == GQUIC_SUCCESS) {
                printf("✓ RTT: %lu ms, CWND: %lu bytes\n", info.rtt_ms, info.cwnd);
            }

            gquic_stream_close(stream);
            gquic_stream_free(stream);
        }

        gquic_connection_free(conn);
    } else {
        printf("✗ Failed to connect to server\n");
    }

    gquic_endpoint_free(client);
}
```

### Server Example

```c
// server_example.c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "gquic.h"

void handle_connection(gquic_connection_t *conn) {
    printf("✓ New client connected\n");

    // Simple echo server logic would go here
    // For now, just cleanup
    gquic_connection_free(conn);
}

int main() {
    printf("GQUIC Server starting...\n");

    // Create runtime
    gquic_runtime_t *runtime = gquic_runtime_new();
    assert(runtime != NULL);

    // Configure server
    gquic_config_t config = {
        .max_idle_timeout_ms = 60000,
        .max_bi_streams = 1000,
        .max_uni_streams = 1000,
        .max_stream_data = 1024 * 1024,
        .max_connection_data = 10 * 1024 * 1024,
        .keep_alive_interval_ms = 10000,
        .enable_0rtt = 1,
    };

    // Create server endpoint
    gquic_endpoint_t *server = gquic_endpoint_new(runtime, "127.0.0.1:4433", &config);
    assert(server != NULL);

    printf("✓ QUIC server listening on 127.0.0.1:4433\n");

    // Accept connections (simplified - in real code you'd loop)
    gquic_connection_t *conn = gquic_endpoint_accept(server);
    if (conn != NULL) {
        handle_connection(conn);
    }

    // Cleanup
    gquic_endpoint_free(server);
    gquic_runtime_free(runtime);

    printf("GQUIC server shutdown complete\n");
    return 0;
}
```

## C++ Wrapper

### Modern C++ Wrapper

```cpp
// gquic.hpp
#ifndef GQUIC_HPP
#define GQUIC_HPP

#include <string>
#include <vector>
#include <memory>
#include <stdexcept>
#include <functional>
#include "gquic.h"

namespace gquic {

class QuicError : public std::runtime_error {
public:
    explicit QuicError(int error_code)
        : std::runtime_error(gquic_error_string(error_code))
        , code_(error_code) {}

    int code() const { return code_; }

private:
    int code_;
};

class Config {
public:
    Config() : config_{} {
        config_.max_idle_timeout_ms = 30000;
        config_.max_bi_streams = 100;
        config_.max_uni_streams = 100;
        config_.max_stream_data = 1024 * 1024;
        config_.max_connection_data = 10 * 1024 * 1024;
        config_.keep_alive_interval_ms = 5000;
        config_.enable_0rtt = 0;
    }

    Config& max_idle_timeout(std::chrono::milliseconds timeout) {
        config_.max_idle_timeout_ms = timeout.count();
        return *this;
    }

    Config& max_bi_streams(uint64_t streams) {
        config_.max_bi_streams = streams;
        return *this;
    }

    Config& max_uni_streams(uint64_t streams) {
        config_.max_uni_streams = streams;
        return *this;
    }

    Config& enable_0rtt(bool enable) {
        config_.enable_0rtt = enable ? 1 : 0;
        return *this;
    }

    const gquic_config_t& native() const { return config_; }

private:
    gquic_config_t config_;
};

class Runtime {
public:
    Runtime() : runtime_(gquic_runtime_new()) {
        if (!runtime_) {
            throw QuicError(GQUIC_ERROR_OUT_OF_MEMORY);
        }
    }

    ~Runtime() {
        if (runtime_) {
            gquic_runtime_free(runtime_);
        }
    }

    // Non-copyable
    Runtime(const Runtime&) = delete;
    Runtime& operator=(const Runtime&) = delete;

    // Movable
    Runtime(Runtime&& other) noexcept : runtime_(other.runtime_) {
        other.runtime_ = nullptr;
    }

    Runtime& operator=(Runtime&& other) noexcept {
        if (this != &other) {
            if (runtime_) {
                gquic_runtime_free(runtime_);
            }
            runtime_ = other.runtime_;
            other.runtime_ = nullptr;
        }
        return *this;
    }

    gquic_runtime_t* native() const { return runtime_; }

private:
    gquic_runtime_t* runtime_;
};

class Stream {
public:
    explicit Stream(gquic_stream_t* stream) : stream_(stream) {}

    ~Stream() {
        if (stream_) {
            gquic_stream_close(stream_);
            gquic_stream_free(stream_);
        }
    }

    // Non-copyable
    Stream(const Stream&) = delete;
    Stream& operator=(const Stream&) = delete;

    // Movable
    Stream(Stream&& other) noexcept : stream_(other.stream_) {
        other.stream_ = nullptr;
    }

    Stream& operator=(Stream&& other) noexcept {
        if (this != &other) {
            if (stream_) {
                gquic_stream_close(stream_);
                gquic_stream_free(stream_);
            }
            stream_ = other.stream_;
            other.stream_ = nullptr;
        }
        return *this;
    }

    void write(const std::vector<uint8_t>& data) {
        int result = gquic_stream_write(stream_, data.data(), data.size());
        if (result != GQUIC_SUCCESS) {
            throw QuicError(result);
        }
    }

    void write(const std::string& data) {
        std::vector<uint8_t> bytes(data.begin(), data.end());
        write(bytes);
    }

    std::vector<uint8_t> read(size_t max_size = 8192) {
        std::vector<uint8_t> buffer(max_size);
        size_t bytes_read;

        int result = gquic_stream_read(
            stream_,
            buffer.data(),
            buffer.size(),
            &bytes_read
        );

        if (result != GQUIC_SUCCESS) {
            throw QuicError(result);
        }

        buffer.resize(bytes_read);
        return buffer;
    }

    std::string read_string(size_t max_size = 8192) {
        auto data = read(max_size);
        return std::string(data.begin(), data.end());
    }

    void close() {
        if (stream_) {
            int result = gquic_stream_close(stream_);
            if (result != GQUIC_SUCCESS) {
                throw QuicError(result);
            }
        }
    }

private:
    gquic_stream_t* stream_;
};

struct ConnectionInfo {
    std::string peer_address;
    uint64_t rtt_ms;
    uint64_t cwnd;
    uint64_t bytes_sent;
    uint64_t bytes_received;
    uint64_t packets_sent;
    uint64_t packets_received;
    uint64_t packets_lost;
};

class Connection {
public:
    explicit Connection(gquic_connection_t* conn) : connection_(conn) {}

    ~Connection() {
        if (connection_) {
            gquic_connection_free(connection_);
        }
    }

    // Non-copyable
    Connection(const Connection&) = delete;
    Connection& operator=(const Connection&) = delete;

    // Movable
    Connection(Connection&& other) noexcept : connection_(other.connection_) {
        other.connection_ = nullptr;
    }

    Connection& operator=(Connection&& other) noexcept {
        if (this != &other) {
            if (connection_) {
                gquic_connection_free(connection_);
            }
            connection_ = other.connection_;
            other.connection_ = nullptr;
        }
        return *this;
    }

    std::unique_ptr<Stream> open_bi_stream() {
        gquic_stream_t* stream = gquic_connection_open_bi_stream(connection_);
        if (!stream) {
            throw QuicError(GQUIC_ERROR_STREAM_FAILED);
        }
        return std::make_unique<Stream>(stream);
    }

    ConnectionInfo info() const {
        gquic_connection_info_t native_info;
        int result = gquic_connection_info(connection_, &native_info);
        if (result != GQUIC_SUCCESS) {
            throw QuicError(result);
        }

        return ConnectionInfo{
            .peer_address = std::string(native_info.peer_address),
            .rtt_ms = native_info.rtt_ms,
            .cwnd = native_info.cwnd,
            .bytes_sent = native_info.bytes_sent,
            .bytes_received = native_info.bytes_received,
            .packets_sent = native_info.packets_sent,
            .packets_received = native_info.packets_received,
            .packets_lost = native_info.packets_lost,
        };
    }

private:
    gquic_connection_t* connection_;
};

class Endpoint {
public:
    Endpoint(Runtime& runtime, const std::string& bind_addr, const Config& config = Config{})
        : endpoint_(gquic_endpoint_new(runtime.native(), bind_addr.c_str(), &config.native())) {
        if (!endpoint_) {
            throw QuicError(GQUIC_ERROR_CONNECTION_FAILED);
        }
    }

    ~Endpoint() {
        if (endpoint_) {
            gquic_endpoint_free(endpoint_);
        }
    }

    // Non-copyable
    Endpoint(const Endpoint&) = delete;
    Endpoint& operator=(const Endpoint&) = delete;

    // Movable
    Endpoint(Endpoint&& other) noexcept : endpoint_(other.endpoint_) {
        other.endpoint_ = nullptr;
    }

    Endpoint& operator=(Endpoint&& other) noexcept {
        if (this != &other) {
            if (endpoint_) {
                gquic_endpoint_free(endpoint_);
            }
            endpoint_ = other.endpoint_;
            other.endpoint_ = nullptr;
        }
        return *this;
    }

    std::unique_ptr<Connection> connect(const std::string& server_addr,
                                      const std::string& server_name = "localhost") {
        gquic_connection_t* conn = gquic_endpoint_connect(
            endpoint_,
            server_addr.c_str(),
            server_name.c_str()
        );

        if (!conn) {
            throw QuicError(GQUIC_ERROR_CONNECTION_FAILED);
        }

        return std::make_unique<Connection>(conn);
    }

    std::unique_ptr<Connection> accept() {
        gquic_connection_t* conn = gquic_endpoint_accept(endpoint_);
        if (!conn) {
            throw QuicError(GQUIC_ERROR_CONNECTION_FAILED);
        }

        return std::make_unique<Connection>(conn);
    }

private:
    gquic_endpoint_t* endpoint_;
};

// Utility functions
inline std::string version() {
    return std::string(gquic_version_string());
}

inline std::string error_string(int error_code) {
    return std::string(gquic_error_string(error_code));
}

} // namespace gquic

#endif // GQUIC_HPP
```

### C++ Usage Example

```cpp
// example.cpp
#include <iostream>
#include <thread>
#include <chrono>
#include "gquic.hpp"

void test_client() {
    try {
        std::cout << "GQUIC version: " << gquic::version() << std::endl;

        gquic::Runtime runtime;
        gquic::Config config;
        config.max_idle_timeout(std::chrono::seconds(30))
              .max_bi_streams(100)
              .enable_0rtt(false);

        // Create client endpoint
        gquic::Endpoint client(runtime, "0.0.0.0:0", config);

        // Connect to server
        auto connection = client.connect("127.0.0.1:4433", "localhost");
        std::cout << "✓ Connected to QUIC server" << std::endl;

        // Open stream and send data
        auto stream = connection->open_bi_stream();
        stream->write("Hello GQUIC from C++!");
        std::cout << "✓ Sent message" << std::endl;

        // Read response
        auto response = stream->read_string();
        std::cout << "✓ Received: " << response << std::endl;

        // Get connection statistics
        auto info = connection->info();
        std::cout << "✓ RTT: " << info.rtt_ms << " ms" << std::endl;
        std::cout << "✓ CWND: " << info.cwnd << " bytes" << std::endl;

    } catch (const gquic::QuicError& e) {
        std::cerr << "QUIC error: " << e.what() << " (code: " << e.code() << ")" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}

void test_server() {
    try {
        gquic::Runtime runtime;
        gquic::Config config;
        config.max_idle_timeout(std::chrono::minutes(1))
              .max_bi_streams(1000)
              .enable_0rtt(true);

        // Create server endpoint
        gquic::Endpoint server(runtime, "127.0.0.1:4433", config);
        std::cout << "✓ QUIC server listening on 127.0.0.1:4433" << std::endl;

        // Accept connection
        auto connection = server.accept();
        std::cout << "✓ Client connected" << std::endl;

        // Simple echo server logic would go here

    } catch (const gquic::QuicError& e) {
        std::cerr << "QUIC error: " << e.what() << " (code: " << e.code() << ")" << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
}

int main() {
    // Start server in background thread
    std::thread server_thread(test_server);

    // Give server time to start
    std::this_thread::sleep_for(std::chrono::milliseconds(100));

    // Run client
    test_client();

    // Cleanup
    server_thread.join();

    std::cout << "All tests completed!" << std::endl;
    return 0;
}
```

## CMake Integration

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(gquic_example)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find the GQUIC library
find_library(GQUIC_LIBRARY
    NAMES gquic_c
    PATHS ${CMAKE_SOURCE_DIR}/target/release
    REQUIRED
)

# Find the GQUIC headers
find_path(GQUIC_INCLUDE_DIR
    NAMES gquic.h
    PATHS ${CMAKE_SOURCE_DIR}/include
    REQUIRED
)

# Create imported target
add_library(gquic::gquic UNKNOWN IMPORTED)
set_target_properties(gquic::gquic PROPERTIES
    IMPORTED_LOCATION ${GQUIC_LIBRARY}
    INTERFACE_INCLUDE_DIRECTORIES ${GQUIC_INCLUDE_DIR}
)

# C client example
add_executable(c_client client_example.c)
target_link_libraries(c_client
    gquic::gquic
    pthread
    dl
    m
)

# C server example
add_executable(c_server server_example.c)
target_link_libraries(c_server
    gquic::gquic
    pthread
    dl
    m
)

# C++ example
add_executable(cpp_example example.cpp)
target_link_libraries(cpp_example
    gquic::gquic
    pthread
    dl
    m
)

# Custom target to build Rust library
add_custom_target(build_rust_lib
    COMMAND cargo build --release
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "Building Rust GQUIC library"
)

# Make sure Rust library is built before our targets
add_dependencies(c_client build_rust_lib)
add_dependencies(c_server build_rust_lib)
add_dependencies(cpp_example build_rust_lib)
```

### Building with CMake

```bash
# Create build directory
mkdir build && cd build

# Configure and build
cmake ..
cmake --build .

# Run examples
./c_client
./c_server
./cpp_example
```

## Error Handling

### Comprehensive Error Handling

```c
// error_handling.c
#include "gquic.h"
#include <stdio.h>

int safe_quic_operation() {
    gquic_runtime_t *runtime = NULL;
    gquic_endpoint_t *endpoint = NULL;
    gquic_connection_t *connection = NULL;

    // Create runtime
    runtime = gquic_runtime_new();
    if (!runtime) {
        printf("Error: Failed to create QUIC runtime\n");
        return GQUIC_ERROR_OUT_OF_MEMORY;
    }

    // Create endpoint
    gquic_config_t config = {
        .max_idle_timeout_ms = 30000,
        .max_bi_streams = 100,
        .max_uni_streams = 100,
        .max_stream_data = 1024 * 1024,
        .max_connection_data = 10 * 1024 * 1024,
        .keep_alive_interval_ms = 5000,
        .enable_0rtt = 0,
    };

    endpoint = gquic_endpoint_new(runtime, "0.0.0.0:0", &config);
    if (!endpoint) {
        printf("Error: Failed to create QUIC endpoint: %s\n",
               gquic_error_string(GQUIC_ERROR_CONNECTION_FAILED));
        gquic_runtime_free(runtime);
        return GQUIC_ERROR_CONNECTION_FAILED;
    }

    // Attempt connection
    connection = gquic_endpoint_connect(endpoint, "127.0.0.1:4433", "localhost");
    if (!connection) {
        printf("Error: Failed to connect to server: %s\n",
               gquic_error_string(GQUIC_ERROR_CONNECTION_FAILED));
        gquic_endpoint_free(endpoint);
        gquic_runtime_free(runtime);
        return GQUIC_ERROR_CONNECTION_FAILED;
    }

    printf("✓ Successfully connected to QUIC server\n");

    // Cleanup in reverse order
    gquic_connection_free(connection);
    gquic_endpoint_free(endpoint);
    gquic_runtime_free(runtime);

    return GQUIC_SUCCESS;
}

int main() {
    int result = safe_quic_operation();
    if (result != GQUIC_SUCCESS) {
        printf("Operation failed with error: %s\n", gquic_error_string(result));
        return result;
    }

    printf("✓ QUIC operation completed successfully\n");
    return 0;
}
```

This completes the GQUIC C/C++ integration guide. The bindings provide a clean, safe interface for using GQUIC from C and C++ while maintaining all the performance and security characteristics of the Rust implementation.